// ZCPUInstrInfo.td-Describe the ZCPU Instructions-*- tablegen -*-
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief ZCPU Instruction definitions.
///
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// ZCPU Instruction Predicate Definitions.
//===----------------------------------------------------------------------===//

def HasAddr32 : Predicate<"!Subtarget->hasAddr64()">;
def HasAddr64 : Predicate<"Subtarget->hasAddr64()">;
def HasSIMD128 : Predicate<"Subtarget->hasSIMD128()">,
                           AssemblerPredicate<"FeatureSIMD128", "simd128">;

//===----------------------------------------------------------------------===//
// ZCPU-specific DAG Node Types.
//===----------------------------------------------------------------------===//

def SDT_ZCPUCallSeqStart : SDCallSeqStart<[SDTCisVT<0, iPTR>]>;
def SDT_ZCPUCallSeqEnd :
    SDCallSeqEnd<[SDTCisVT<0, iPTR>, SDTCisVT<1, iPTR>]>;
def SDT_ZCPUCall0    : SDTypeProfile<0, -1, [SDTCisPtrTy<0>]>;
def SDT_ZCPUCall1    : SDTypeProfile<1, -1, [SDTCisPtrTy<1>]>;
def SDT_ZCPUBrTable  : SDTypeProfile<0, -1, [SDTCisPtrTy<0>]>;
def SDT_ZCPUArgument : SDTypeProfile<1, 1, [SDTCisVT<1, i32>]>;
def SDT_ZCPUReturn   : SDTypeProfile<0, -1, []>;
def SDT_ZCPUWrapper  : SDTypeProfile<1, 1, [SDTCisSameAs<0, 1>,
                                                   SDTCisPtrTy<0>]>;

//===----------------------------------------------------------------------===//
// ZCPU-specific DAG Nodes.
//===----------------------------------------------------------------------===//

def ZCPUcallseq_start :
    SDNode<"ISD::CALLSEQ_START", SDT_ZCPUCallSeqStart,
           [SDNPHasChain, SDNPOutGlue]>;
def ZCPUcallseq_end :
    SDNode<"ISD::CALLSEQ_END", SDT_ZCPUCallSeqEnd,
           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
def ZCPUcall0 : SDNode<"ZCPUISD::CALL0",
                              SDT_ZCPUCall0,
                              [SDNPHasChain, SDNPVariadic]>;
def ZCPUcall1 : SDNode<"ZCPUISD::CALL1",
                              SDT_ZCPUCall1,
                              [SDNPHasChain, SDNPVariadic]>;
def ZCPUbr_table : SDNode<"ZCPUISD::BR_TABLE",
                                 SDT_ZCPUBrTable,
                                 [SDNPHasChain, SDNPVariadic]>;
def ZCPUargument : SDNode<"ZCPUISD::ARGUMENT",
                                 SDT_ZCPUArgument>;
def ZCPUreturn   : SDNode<"ZCPUISD::RETURN",
                                 SDT_ZCPUReturn, [SDNPHasChain]>;
def ZCPUwrapper  : SDNode<"ZCPUISD::Wrapper",
                                 SDT_ZCPUWrapper>;

//===----------------------------------------------------------------------===//
// ZCPU-specific Operands.
//===----------------------------------------------------------------------===//

let OperandNamespace = "ZCPU" in {

let OperandType = "OPERAND_BASIC_BLOCK" in
def bb_op : Operand<OtherVT>;

let OperandType = "OPERAND_FP32IMM" in
def f32imm_op : Operand<f32>;

let OperandType = "OPERAND_FP64IMM" in
def f64imm_op : Operand<f64>;

let OperandType = "OPERAND_P2ALIGN" in {
def P2Align : Operand<i32> {
  let PrintMethod = "printZCPUP2AlignOperand";
}
} // OperandType = "OPERAND_P2ALIGN"

} // OperandNamespace = "ZCPU"

//===----------------------------------------------------------------------===//
// ZCPU Instruction Format Definitions.
//===----------------------------------------------------------------------===//

include "ZCPUInstrFormats.td"

//===----------------------------------------------------------------------===//
// Additional instructions.
//===----------------------------------------------------------------------===//

multiclass ARGUMENT<ZCPURegClass vt> {
  let hasSideEffects = 1, Uses = [ARGUMENTS], isCodeGenOnly = 1 in
  def ARGUMENT_#vt : I<(outs vt:$res), (ins i32imm:$argno),
                       [(set vt:$res, (ZCPUargument timm:$argno))]>;
}
defm : ARGUMENT<I32>;
defm : ARGUMENT<F64>;

let Defs = [ARGUMENTS] in {

// get_local and set_local are not generated by instruction selection; they
// are implied by virtual register uses and defs.
multiclass LOCAL<ZCPURegClass vt> {
let hasSideEffects = 0 in {
  // COPY_LOCAL is not an actual instruction in wasm, but since we allow
  // get_local and set_local to be implicit, we can have a COPY_LOCAL which
  // is actually a no-op because all the work is done in the implied
  // get_local and set_local.
  let isAsCheapAsAMove = 1 in
  def COPY_LOCAL_#vt : I<(outs vt:$res), (ins vt:$src), [],
                         "copy_local\t$res, $src">;

  // TEE_LOCAL is similar to COPY_LOCAL, but writes two copies of its result.
  // Typically this would be used to stackify one result and write the other
  // result to a local.
  let isAsCheapAsAMove = 1 in
  def TEE_LOCAL_#vt : I<(outs vt:$res, vt:$also), (ins vt:$src), [],
                        "tee_local\t$res, $also, $src">;
} // hasSideEffects = 0
}
defm : LOCAL<I32>;
defm : LOCAL<F64>;

let isMoveImm = 1, isAsCheapAsAMove = 1, isReMaterializable = 1 in {
def CONST_I32 : I<(outs I32:$res), (ins i32imm:$imm),
                  [(set I32:$res, imm:$imm)],
                  "i32.const\t$res, $imm">;
def CONST_F64 : I<(outs F64:$res), (ins f64imm_op:$imm),
                  [(set F64:$res, fpimm:$imm)],
                  "f64.const\t$res, $imm">;
} // isMoveImm = 1, isAsCheapAsAMove = 1, isReMaterializable = 1

} // Defs = [ARGUMENTS]

def : Pat<(i32 (ZCPUwrapper tglobaladdr:$addr)),
          (CONST_I32 tglobaladdr:$addr)>;
def : Pat<(i32 (ZCPUwrapper texternalsym:$addr)),
          (CONST_I32 texternalsym:$addr)>;

//===----------------------------------------------------------------------===//
// Additional sets of instructions.
//===----------------------------------------------------------------------===//

