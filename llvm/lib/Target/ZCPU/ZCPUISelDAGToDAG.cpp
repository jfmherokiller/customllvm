//- ZCPUISelDAGToDAG.cpp - A dag to dag inst selector for ZCPU -//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief This file defines an instruction selector for the ZCPU target.
///
//===----------------------------------------------------------------------===//

#include "ZCPU.h"
#include "MCTargetDesc/ZCPUMCTargetDesc.h"
#include "ZCPUTargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Function.h" // To access function attributes.
#include "llvm/Support/Debug.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "zcpu-isel"

//===--------------------------------------------------------------------===//
/// ZCPU-specific code to select ZCPU machine instructions for
/// SelectionDAG operations.
///
namespace {
    class ZCPUDAGToDAGISel final : public SelectionDAGISel {
        /// Keep a pointer to the ZCPUSubtarget around so that we can make the
        /// right decision when generating code for different targets.
        const ZCPUSubtarget *Subtarget;

        bool ForCodeSize;

    public:
        ZCPUDAGToDAGISel(ZCPUTargetMachine &tm,
                         CodeGenOpt::Level OptLevel)
                : SelectionDAGISel(tm, OptLevel), Subtarget(nullptr), ForCodeSize(false) {
        }

        const char *getPassName() const override {
            return "ZCPU Instruction Selection";
        }

        bool runOnMachineFunction(MachineFunction &MF) override {
            ForCodeSize =
                    MF.getFunction()->hasFnAttribute(Attribute::OptimizeForSize) ||
                    MF.getFunction()->hasFnAttribute(Attribute::MinSize);
            Subtarget = &MF.getSubtarget<ZCPUSubtarget>();
            return SelectionDAGISel::runOnMachineFunction(MF);
        }

        void Select(SDNode *Node) override;

        bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
                                          std::vector<SDValue> &OutOps) override;

// Include the pieces autogenerated from the target description.
#include "ZCPUGenDAGISel.inc"

    private:
        // add select functions here...
        bool SelectAddr(SDNode *Parent, SDValue Addr, SDValue &Base, SDValue &Offset);
    };
} // end anonymous namespace

void ZCPUDAGToDAGISel::Select(SDNode *Node) {
    // Dump information about the Node being selected.
    DEBUG(errs() << "Selecting: ");
    DEBUG(Node->dump(CurDAG));
    DEBUG(errs() << "\n");

    // If we have a custom node, we already have selected!
    if (Node->isMachineOpcode()) {
        DEBUG(errs() << "== ";
                      Node->dump(CurDAG);
                      errs() << "\n");
        Node->setNodeId(-1);
        return;
    }

    // Few custom selection stuff.
    EVT VT = Node->getValueType(0);

    switch (Node->getOpcode()) {
        default:
            break;
            // If we need ZCPU-specific selection, it would go here.
            (void) VT;
    }

    // Select the default instruction.
    SelectCode(Node);
}
bool ZCPUDAGToDAGISel::SelectAddr(SDNode *Parent, SDValue Addr, SDValue &Base, SDValue &Offset) {
//@SelectAddr }
    EVT ValTy = Addr.getValueType();
    SDLoc DL(Addr);

    // If Parent is an unaligned f32 load or store, select a (base + index)
    // floating point load/store instruction (luxc1 or suxc1).
    const LSBaseSDNode* LS = 0;

    if (Parent && (LS = dyn_cast<LSBaseSDNode>(Parent))) {
        EVT VT = LS->getMemoryVT();

        if (VT.getSizeInBits() / 8 > LS->getAlignment()) {
            assert("Unaligned loads/stores not supported for this type.");
            if (VT == MVT::f32)
                return false;
        }
    }

    // if Address is FI, get the TargetFrameIndex.
    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        Base   = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
        Offset = CurDAG->getTargetConstant(0, DL, ValTy);
        return true;
    }
    // on PIC code Load GA
    if (Addr.getOpcode() == ZCPUISD::Wrapper) {
        Base   = Addr.getOperand(0);
        Offset = Addr.getOperand(1);
        return true;
    }

    //@static
    if (TM.getRelocationModel() != Reloc::PIC_) {
        if ((Addr.getOpcode() == ISD::TargetExternalSymbol ||
             Addr.getOpcode() == ISD::TargetGlobalAddress))
            return false;
    }
    // Addresses of the form FI+const or FI|const
    if (CurDAG->isBaseWithConstantOffset(Addr)) {
        ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
        if (isInt<32>(CN->getSExtValue())) {

            // If the first operand is a FI, get the TargetFI Node
            if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>
                    (Addr.getOperand(0)))
                Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
            else
                Base = Addr.getOperand(0);

            Offset = CurDAG->getTargetConstant(CN->getZExtValue(), DL, ValTy);
            return true;
        }
    }

    Base   = Addr;
    Offset = CurDAG->getTargetConstant(0, DL, ValTy);
    return true;
}

bool ZCPUDAGToDAGISel::SelectInlineAsmMemoryOperand(
        const SDValue &Op, unsigned ConstraintID, std::vector<SDValue> &OutOps) {
    switch (ConstraintID) {
        case InlineAsm::Constraint_i:
        case InlineAsm::Constraint_m:
            // We just support simple memory operands that just have a single address
            // operand and need no special handling.
            OutOps.push_back(Op);
            return false;
        default:
            break;
    }

    return true;
}

/// This pass converts a legalized DAG into a ZCPU-specific DAG, ready
/// for instruction scheduling.
FunctionPass *llvm::createZCPUISelDag(ZCPUTargetMachine &TM,
                                      CodeGenOpt::Level OptLevel) {
    return new ZCPUDAGToDAGISel(TM, OptLevel);
}
